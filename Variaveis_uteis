# VARIAVEIS ÚTEIS  #

Caracteres Úteis

 - Aspas " - Tudo entre aspas é ignorado, exceto $ ` \
 - Crase `- Eexecuta um comando entre crases (tudo que estiver entre a cráse é interpretdada como comando)

 - Barra invertida \ - Ignora apenas o caractere seguinte (Ex. mkdir aula 2 com espaço o linux vai criar dois diretórios, aula e 2 porém utilizando da forma mkdir aula\ 2 , dessa forma vai criar o diretório aula 2 ignorando o espaço após a barra.
 
 - Apóstrofo ' - Ignora tudo entre apóstrofos 
 - Ponto e vírgula ; - Mundaça de linha


#  REDIRECIONAMENTO #
#
stdout - saída padrão, seu default é a tela 
stdom - entrada padrão, seu default é o teclado
stderr - saída de erro, seu default tabmém é a tela 
>  - redirecionamento de saida (sobrescreve)
>> - redirecionamento de saída (incrementa)
2> - redirecionaemnto de erro (ls -e 2> /dev/null - joga a saida de erro para a lixeira.

<  - redirecionamento de entrada
|  - concatena uma saída em uma entrada


# PARÂMETROS (CONFERIR ITERAÇÃO COM O USUÁRIO DURANTA A EXECUÇÃO)
#
Ex.
ls -l  (l=parâmetro)

$0 => é o próprio interpretador caso  não esteja manipulando nenhum código.

$0 - $9 => Parâmetros posśiveis 

${10} => Referencia o parâmetro 10

$* =>  Utz todos parâmetros usados como string única

$? => Saber se foi executado com sucesso [1 ou 0]

$# - Saber qtd parâmetrops inseridos pelo usuário


# ESTRUTURAS DE CONTROLE 


#IF

 if, test, for, while, until, case

if [condição]                se executado com sucesso ($?=0)
then                         Então
   <comando>			
   <comando>		     Executa os comandos
else                         SENÃO
  <comando> 
  <comando>                  Executa esses comandos
fi                           FIM


#ELIF

if [condição]                se executado com sucesso ($?=0)
then                         Então
   <comando>                 Executa comando 1
elif[condicao2]              Se cond1 não satisfazer, mais sim a 2 
  <comando>                  Executa comando 2
elif[condicao3]              Se a cond2 não satisfazer, mais sim a 3
  <comando3>                 Execute comando 3  
fi                           FIM


#TEST
#
Uso:

   test 3 -gt 4
   
   ou
    [3 -gt 4]

#Tabela

-eq = Igual
-ne = Diferente
-gt = Maior
-lt = Menor
-o  = Ou
-d  = Se for um diretório
-e  = Se existir
-z  = Se estiver vazio
-f  = Se conter texto
-o  = Se o usuário for o dono
-r  = Se o arquivo pode ser lido
-w  = Se o arquivo pode ser alterado
-x  = Seo arquivo pode ser executado

#Exemplos
 
if[4 -gt 3] #se 4 for maior que 3
if[$2 -lt 4] #Se o segundo parâmetro for menor que 4
if[$var1 -eq $var2] #Se a variável 1 for igual a v ariável 2
if[`ls /teste` -Z] # Se diretório estiver vazio 
if[bola = bola] #comparação entre strings
if[$var3 = bola] #Compara o conteúdo da variável 3 com a string "bola"


#LOOPs

#FOR

for ((x=0;x<=13;x++))  # cria um laço para contar de 0 a 13
do                     # faça
  echo "$x"            # Exiba o valor da variável
done		       # Feito

#Outras formas de uso do comando for

for i in $(seq 10) # i assumirá valores de 0 a 10

for i in $(cat arquivo.txt) # i assumirá o valor de cada linha do arquivo

for i in param[1-5] # i assumirá valores dos parâmetros 1 a 5

for ((x=0;x<=13;x++)) # os comandos do laço assumirão os valores de 0 a 13


#WHILE

while [expressão]       # Enquando $?=0 (bem sucedido)
do                      # Faça
   <comando1>           # Execute o comando1
done                    # Feito


#UNTIL (contrario do WHILE)

until [expressao]  # Enquanto $?=1 (sem sucesso - minha condição for falsa)
do                 # Faça
  <comando>        # Execute o comando1
done               # Feito


# ESTRUTURAS DE CONTROLE DE FLUXO
#

case $var in    	# no caso da variável var receber os valores
1)			# [var = 1 ]
	<comando1>      # Executa o comando1
2)                      # [ $var = 2 ]
        <comando2>      # Executa o comando2
*)                      # [ $var -ne 1 ] || [ $var -ne 2 ]
        <comando3>      # Execute o comando3
esac                    # fim


#TRATAMENTO DE CONTEÚDO
#
#grep, cut, tr, sed, awk

#grep  
grep - Regexi sim ou não (filgragem de conteúdo)
egrep  - regex completas 
fgrep - regex s/ metacaracteres (quando formos pesquisar string literal)



  
